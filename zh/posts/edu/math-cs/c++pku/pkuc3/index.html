<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++程序设计 | Atom.X</title><meta name=keywords content="互联网,数学&计算机,AI"><meta name=description content="原课程链接：C++程序设计
cplusplus.com
教材《新标准 c++程序设计》 郭炜, 清华大学
w11. C++11 新特性
auto 自动变量类型
decltype 关键字，求表达式类型
shared_ptr 智能指针
nullptr 空指针
基于范围的for循环
右值引用和move语义
unordered_map 无序容器(哈希表)
regex 正则表达式
Lambda 表达式
强制类型转换
static_cast、interpret_cast
const_cast和dynamic_cast
C++异常处理基础：try、throw、catch
意外异常(unexpected exception)
动态内存管理的异常处理 new
w9. STL -
质因数数目
container adapter 容器适配器
(让已有的顺序容器以栈/队列的方式工作)
stack
queue
priority_queue
member function
push
top
pop
参考案例：github/ PKUC3/ 3.10.1.4.cpp
map/ multimap
map 容器中，关键字key是唯一的，值value可以重复。
multimap 容器中，关键字和值都可以重复。
set/ multiset
set 容器中，元素是唯一的，按其值自动排序，而非插入顺序。
添加新对象时会比较对象的大小，set 是一个基于红黑树实现的容器，它会自动将元素按照特定的顺序存储，通常是使用元素的 < 操作符来进行比较和排序。
set 容器的迭代器支持双向迭代，可以使用++，- - 移动迭代器，但不支持随机访问，所以不能进行 i+1 的操作；"><meta name=author content="Atom.X"><link rel=canonical href=https://atomx.cc/zh/posts/edu/math-cs/c++pku/pkuc3/><meta name=google-site-verification content="XYZabc123"><meta name=yandex-verification content="XYZabc789"><meta name=msvalidate.01 content="XYZabc456"><link crossorigin=anonymous href=../../../../../../assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://atomx.cc/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://atomx.cc/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://atomx.cc/favicon-32x32.png><link rel=apple-touch-icon href=https://atomx.cc/apple-touch-icon.png><link rel=mask-icon href=https://atomx.cc/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://atomx.cc/zh/posts/edu/math-cs/c++pku/pkuc3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://atomx.cc/zh/posts/edu/math-cs/c++pku/pkuc3/"><meta property="og:site_name" content="Atom.X"><meta property="og:title" content="C++程序设计"><meta property="og:description" content="原课程链接：C++程序设计
cplusplus.com
教材《新标准 c++程序设计》 郭炜, 清华大学
w11. C++11 新特性 auto 自动变量类型
decltype 关键字，求表达式类型
shared_ptr 智能指针
nullptr 空指针
基于范围的for循环
右值引用和move语义
unordered_map 无序容器(哈希表)
regex 正则表达式
Lambda 表达式
强制类型转换 static_cast、interpret_cast const_cast和dynamic_cast
C++异常处理基础：try、throw、catch 意外异常(unexpected exception) 动态内存管理的异常处理 new
w9. STL - 质因数数目
container adapter 容器适配器 (让已有的顺序容器以栈/队列的方式工作)
stack
queue
priority_queue
member function
push
top
pop
参考案例：github/ PKUC3/ 3.10.1.4.cpp
map/ multimap map 容器中，关键字key是唯一的，值value可以重复。
multimap 容器中，关键字和值都可以重复。
set/ multiset set 容器中，元素是唯一的，按其值自动排序，而非插入顺序。
添加新对象时会比较对象的大小，set 是一个基于红黑树实现的容器，它会自动将元素按照特定的顺序存储，通常是使用元素的 < 操作符来进行比较和排序。
set 容器的迭代器支持双向迭代，可以使用++，- - 移动迭代器，但不支持随机访问，所以不能进行 i+1 的操作；"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-12T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-12T00:00:00+00:00"><meta property="article:tag" content="互联网"><meta property="article:tag" content="数学&计算机"><meta property="article:tag" content="AI"><meta property="og:image" content="https://atomx.cc/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://atomx.cc/images/papermod-cover.png"><meta name=twitter:title content="C++程序设计"><meta name=twitter:description content="原课程链接：C++程序设计
cplusplus.com
教材《新标准 c++程序设计》 郭炜, 清华大学
w11. C++11 新特性
auto 自动变量类型
decltype 关键字，求表达式类型
shared_ptr 智能指针
nullptr 空指针
基于范围的for循环
右值引用和move语义
unordered_map 无序容器(哈希表)
regex 正则表达式
Lambda 表达式
强制类型转换
static_cast、interpret_cast
const_cast和dynamic_cast
C++异常处理基础：try、throw、catch
意外异常(unexpected exception)
动态内存管理的异常处理 new
w9. STL -
质因数数目
container adapter 容器适配器
(让已有的顺序容器以栈/队列的方式工作)
stack
queue
priority_queue
member function
push
top
pop
参考案例：github/ PKUC3/ 3.10.1.4.cpp
map/ multimap
map 容器中，关键字key是唯一的，值value可以重复。
multimap 容器中，关键字和值都可以重复。
set/ multiset
set 容器中，元素是唯一的，按其值自动排序，而非插入顺序。
添加新对象时会比较对象的大小，set 是一个基于红黑树实现的容器，它会自动将元素按照特定的顺序存储，通常是使用元素的 < 操作符来进行比较和排序。
set 容器的迭代器支持双向迭代，可以使用++，- - 移动迭代器，但不支持随机访问，所以不能进行 i+1 的操作；"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://atomx.cc/zh/posts/"},{"@type":"ListItem","position":2,"name":"C++程序设计","item":"https://atomx.cc/zh/posts/edu/math-cs/c++pku/pkuc3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++程序设计","name":"C\u002b\u002b程序设计","description":"原课程链接：C++程序设计\ncplusplus.com\n教材《新标准 c++程序设计》 郭炜, 清华大学\nw11. C++11 新特性 auto 自动变量类型\ndecltype 关键字，求表达式类型\nshared_ptr 智能指针\nnullptr 空指针\n基于范围的for循环\n右值引用和move语义\nunordered_map 无序容器(哈希表)\nregex 正则表达式\nLambda 表达式\n强制类型转换 static_cast、interpret_cast const_cast和dynamic_cast\nC++异常处理基础：try、throw、catch 意外异常(unexpected exception) 动态内存管理的异常处理 new\nw9. STL - 质因数数目\ncontainer adapter 容器适配器 (让已有的顺序容器以栈/队列的方式工作)\nstack\nqueue\npriority_queue\nmember function\npush\ntop\npop\n参考案例：github/ PKUC3/ 3.10.1.4.cpp\nmap/ multimap map 容器中，关键字key是唯一的，值value可以重复。\nmultimap 容器中，关键字和值都可以重复。\nset/ multiset set 容器中，元素是唯一的，按其值自动排序，而非插入顺序。\n添加新对象时会比较对象的大小，set 是一个基于红黑树实现的容器，它会自动将元素按照特定的顺序存储，通常是使用元素的 \u0026lt; 操作符来进行比较和排序。\nset 容器的迭代器支持双向迭代，可以使用++，- - 移动迭代器，但不支持随机访问，所以不能进行 i+1 的操作；\n","keywords":["互联网","数学\u0026计算机","AI"],"articleBody":"原课程链接：C++程序设计\ncplusplus.com\n教材《新标准 c++程序设计》 郭炜, 清华大学\nw11. C++11 新特性 auto 自动变量类型\ndecltype 关键字，求表达式类型\nshared_ptr 智能指针\nnullptr 空指针\n基于范围的for循环\n右值引用和move语义\nunordered_map 无序容器(哈希表)\nregex 正则表达式\nLambda 表达式\n强制类型转换 static_cast、interpret_cast const_cast和dynamic_cast\nC++异常处理基础：try、throw、catch 意外异常(unexpected exception) 动态内存管理的异常处理 new\nw9. STL - 质因数数目\ncontainer adapter 容器适配器 (让已有的顺序容器以栈/队列的方式工作)\nstack\nqueue\npriority_queue\nmember function\npush\ntop\npop\n参考案例：github/ PKUC3/ 3.10.1.4.cpp\nmap/ multimap map 容器中，关键字key是唯一的，值value可以重复。\nmultimap 容器中，关键字和值都可以重复。\nset/ multiset set 容器中，元素是唯一的，按其值自动排序，而非插入顺序。\n添加新对象时会比较对象的大小，set 是一个基于红黑树实现的容器，它会自动将元素按照特定的顺序存储，通常是使用元素的 \u003c 操作符来进行比较和排序。\nset 容器的迭代器支持双向迭代，可以使用++，- - 移动迭代器，但不支持随机访问，所以不能进行 i+1 的操作；\nmultiset 容器中，元素可以重复，并且按其值自动排序。\nvector vector 容器支持随机访问，例如 int i=0, num[i]；\n一个动态数组，可以在尾部快速添加或删除对象，但不会自动排序。\nlist list 容器是一个双向链表，可在任何位置快速添加或删除对象，不会自动排序；\n不支持随机访问，只能通过顺序访问，因此不能使用下标操作符（[]），小于(\u003c)操作 或者在迭代器上进行加法操作（ii + 1）。\n只能使用不等于(!=)操作符来比较迭代器和容器的**end()，以及迭代器的递增操作符（++**），直到达到容器末尾：\nlist \u003cint\u003e v; list \u003cint\u003e::const_iterator ii; // 不等于(!=)操作，递增操作（++），正确 for(ii = v.begin(); ii != v.end(); ii++) { cout \u003c\u003c *ii; } // 下标操作（[]），加法操作（ii + 1）， 小于操作(\u003c)，报错 for( ii = v.begin(); ii != v.end ();ii = ii +1 ) cout \u003c\u003c * ii; for (int i = 0;i \u003c v.size() ; i ++) cout \u003c\u003c v[i]; for( ii = v.begin(); ii \u003c v.end ();ii ++ ) cout \u003c\u003c * ii;\tdeque 一个双端队列，可以在头部和尾部快速添加或删除对象，但同样不会自动排序。\nThe algorithms in STL • Non-modifying sequence algorithms • Modifying sequence algorithms • Removing algorithms remove, unique,\n• Mutating sequence algorithms reverse, rotate\n• Sorting algorithms\nsort, nth_element\n• Sorted range algorithms\nbinary_search, include, lower_bound, upper_bound, equal_range\n• Numeric algorithms\nw8. STL - standard template library 标准模板库STL，就是一些常用数据结构和算法的模板的集合。将常用的数据结构（比如链表，数组，二叉树）和算法（比如排序，查找）写成模板。\n泛型程序设计(generic programming)\n**容器：**可容纳各种数据类型的通用数据结构,是类模板；\n顺序容器 vector, deque, list 关联容器 set, multiset, map, multimap 容器适配器 stack, queue, priority_queue **迭代器：**可用于依次存取容器中元素，类似于指针；\n容器上的迭代器类别\nvector 随机访问 deque 随机访问 list 双向 set/multiset 双向 map/multimap 双向 stack 不支持迭代器 queue 不支持迭代器 priority_queue 不支持迭代器 **算法：**用来操作容器中的元素的函数模板；\nsort()来对一个vector中的数据进行排序 find()来搜索一个list中的对象 function object 函数对象 如果一个类重载了**()运算符，那么该类的对象可以像函数一样被调用，也叫仿函数**。\n// 创建一个Adder对象addFive，通过addFive(3)来调用，就像调用普通函数一样 class Adder { public: Adder(int n) : num(n) {} // 构造函数 int operator()(int x) const { return num + x; // 重载()运算符，Adder对象可接受整数参数并返回结果 } private: int num; // 内部状态 }; int main() { Adder addFive(5); // 创建一个函数对象，内部状态为5 std::cout \u003c\u003c addFive(3); // 调用函数对象，输出8 return 0; } C++ 中常用的数据结构\n集合（Set）：Set 是基于二叉搜索树（通常是红黑树）实现的，它的主要优点是查找、插入和删除操作的时间复杂度都是 O(logN)。但是，Set 不支持随机访问，即不能像数组或向量那样通过索引直接访问元素。 向量（Vector）：Vector 是一种动态数组，它的主要优点是支持随机访问，访问元素的时间复杂度是 O(1)。但是，如果在 Vector 的中间位置插入或删除元素，可能需要移动大量的元素，所以这类操作的时间复杂度是 O(N)。 列表（List）：List 是一种双向链表，它的主要优点是在任何位置插入或删除元素的时间复杂度都是 O(1)。但是，List 不支持随机访问，访问元素的时间复杂度是 O(N)。 O(logN) time. • set provides fast lookup to check if an id exists in O(logN) time.\nBig O notation is a way to express the upper bound of an algorithm’s time complexity, which is a measure of the amount of time an algorithm takes to run as a function of the size of its input.\nBig O 表示法是一种表达算法时间复杂度上限的方法，它是算法运行时间的度量，作为其输入大小的函数。\n随着元素数量 N 的增加，执行操作所需的时间并不是线性增加（就像在 O(N) 的情况下那样），而是以 N 的对数的比例增长。\n假设p1, p2 是STL中的list 容器上的迭代器，p1 += 1; 不符合语法？\n因为：list 容器的迭代器是双向迭代器，不支持随机访问和算术操作，因此不能直接使用 += 来移动迭代器。\n在STL中，list 容器的迭代器不支持 += 操作符\n移动迭代器 p1 到下一个位置，可以使用 ++p1 或者 p1++\nw7. file operate, template 文件操作、模板\nifstream, ofstream, fstream\ncin» 输入\ncout« 输出\n字符流\nfunction template 函数模板\ntemplate class 模板类 common class 普通类\nstring class 是模板类\ntypedef basic_string string;\n用 template 定义一个类时，创建的是一个可以用于多种数据类型的模板，模板类不是一个具体的类实例，这个模板本身不是一个直接可以使用的类，而是一个用于生成特定类型实例的蓝图。\n参考程序案例：github/ PKUC3/ 3.10.7.cpp\nclass template 类模板 题目：类C1和类C2都是类模板CT的模板类\nC1的成员函数中，不能访问C2的私有成员，除非C2将C1声明为友元。 C1的友元函数中，不能访问C2的私有成员，除非C2将该友元函数声明为友元。 C1的对象，不能直接赋值给C2类型的变量，除非它们是相同的类型或者有适当的类型转换操作定义。 C1的静态成员变量和C2的静态成员变量拥有不同的存储空间。这是因为即使C1和C2是由同一个类模板CT实例化出来的，如果它们的模板参数不同，它们就是不同的类型，每个类型都会有自己的静态成员变量实例。 #include // 类模板定义 template \u003ctypename T\u003e class CT { public: // 静态成员变量 static int staticValue; // 构造函数 CT() { // 初始化静态成员变量 staticValue++; } }; // 静态成员变量的定义和初始化 template \u003ctypename T\u003e int CT\u003cT\u003e::staticValue = 0; int main() { // 实例化一个int类型的CT模板类 CT\u003cint\u003e intInstance; // 使用类名CT创建对象名为intInstance的对象 std::cout \u003c\u003c \"CT::staticValue: \" \u003c\u003c CT\u003cint\u003e::staticValue \u003c\u003c std::endl; // 实例化一个double类型的CT模板类 // 使用类名CT创建对象名为doubleInstance的对象。 CT\u003cdouble\u003e doubleInstance; std::cout \u003c\u003c \"CT::staticValue: \" \u003c\u003c CT\u003cdouble\u003e::staticValue \u003c\u003c std::endl; // 再次创建CT的实例 CT\u003cint\u003e anotherIntInstance; std::cout \u003c\u003c \"CT::staticValue: \" \u003c\u003c CT\u003cint\u003e::staticValue \u003c\u003c std::endl; // 输出结果将显示CT和CT的staticValue是独立存储的 return 0; } // 两个实例intInstance和doubleInstance分别属于两个不同的模板类 // 它们是由同一个类模板（类名）CT通过提供不同的类型参数生成的。 operator运算符:\n算术运算符：+、**、**、/ 等。 比较运算符：==、!=、\u003c、\u003e 等。 逻辑运算符：\u0026\u0026、||、! 等。 位运算符：\u0026、|、^ 等。 stream manipulator 流操纵符:\ncin , cout(与\u003c\u003c, \u003e\u003e 运算符一起使用)、setw、setfill、setprecision、endl、ws、ends、flush\n老版本的北大教材中使用“流操纵算子”的术语，在此统一翻译为“stream manipulator流操纵符”。\n算子（数学概念）与计算机程序中的operator有相通之处，在最新版本的c++库说明文件中，“运算符”替代“算子”的术语。（此处术语有待勘误）\n科学计数法（科学记号）是一种用于表示非常大或非常小数值的方法，形式：\n[ \\text{数} = a \\times 10^n ]\n(2.7 \\times 10^3) = 2700\n(-5.3 \\times 10^4) = -53000\n(7.823E5) = 782300\n(1.2e^{-4}) = 0.00012\ndec, hex, oct format flag for output streams.\nint represents an integer value in decimal (base 10) format.\nw6. polymorphism, virtual function 多态, 虚函数\nabstract class 抽象类\n包含至少一个纯虚函数（pure virtual function）的类\nAbstract classes are used to represent general concepts (for example, Shape, Animal), which can serve as base classes for more specific concrete classes (for example, Circle, Dog).\nThese general concepts often have common properties or behaviors that apply to their derived classes. Abstract classes cannot be instantiated directly; they serve as blueprints for other classes. class Base {// Abstract classes public: // contain at least one pure virtual function virtual void func() { cout \u003c\u003c \"I am in base\" \u003c\u003c endl; } }; // **override identifier 标识符** class Derived : public Base { // override identifier specifies member public: // function overrides virtual function in a base class void func() override { cout \u003c\u003c \"I am in derived class\" \u003c\u003c endl; } }; pure virtual function 纯虚函数\nvirtual destructor 虚析构函数\n若基类的成员函数被声明为虚函数（使用**virtual关键字），那么在派生类中即使不再显式地使用virtual**关键字，该成员函数仍然是虚函数。派生类会继承基类的虚函数属性，并且可以通过多态性来覆盖这些虚函数。\noverride in derived class 從派生類重寫\nIf a derived class overrides a base class method, that method becomes virtual implicitly in the base class. 如果派生类重写基类方法，则该方法在基类中隐式变为虚拟方法。\n// 参考程序案例：github/ PKUC3/ 3.10.1.1.cpp // 程序示例，展示虚函数表、虚函数、纯虚函数和抽象类的用法 #include // 抽象类 class Shape { public: // 纯虚函数，用于计算面积 virtual double area() const = 0; // 虚析构函数 virtual ~Shape() {} }; // 派生类：圆形 class Circle : public Shape { private: double radius; public: Circle(double r) : radius(r) {} // 重写纯虚函数，计算圆形的面积 double area() const override { return 3.14159 * radius * radius; } }; // 派生类：矩形 class Rectangle : public Shape { private: double width, height; public: Rectangle(double w, double h) : width(w), height(h) {} // 重写纯虚函数，计算矩形的面积 double area() const override { return width * height; } }; int main() { // 不能直接创建抽象类的实例 // Shape shape; // 错误：不能实例化抽象类 // 创建派生类的实例 Circle circle(5); Rectangle rectangle(4, 6); // 使用指向基类的指针数组来调用派生类的函数 Shape* shapes[2] = {\u0026circle, \u0026rectangle}; // 通过基类指针调用重写的函数 for (int i = 0; i \u003c 2; ++i) { std::cout \u003c\u003c \"Shape \" \u003c\u003c i + 1 \u003c\u003c \" area: \" \u003c\u003c shapes[i]-\u003earea() \u003c\u003c std::endl; } return 0; } 对象赋值 如果类C2是类C1的派生类，那么可以将C2的对象赋值给C1类型的变量。多态特性，允许派生类对象被视为基类对象，通过指针或引用来实现的。\nclass C1 { // 基类成员 }; class C2 : public C1 { // 派生类成员 }; int main() { C2 objC2; C1* ptrC1 = \u0026objC2; // C2的对象可以赋值给C1类型的指针 C1\u0026 refC1 = objC2; // C2的对象也可以赋值给C1类型的引用 return 0; } w4. operator overloading 运算符重载\n流插入运算符和流提取运算符的重载\ncout«左移，cin»右移，位运算符\ncomplex number 复数类 用于表示和操作复数的编程类\na + bi\n（a）是实数部分，( b ) 是虚数部分，而 ( i ) 是虚数单位，满足 ( i^2 = -1 )。\n普通函数，传入2个参数\n成员函数，传入1个\noperator[ ] index operator, subscript operator overloading\n下标运算符重载\noperator= assignment operator overloading\n赋值运算符重载\nclass String{ private: char *str; public: String():str(NULL){} // 构造函数，初始化为NULL const char *c_str(){ return str; } char *operator = (const char *s); ~String(); }; //重载‘=’→ object = \"hello\" 能够成立 char *String::operator = (const char *s){ if(str == s.str){ return *this; } if(str){ delete[] str; } if(s){ // s！= NULL 时才执行copy str = new char[strlen(s) + 1]; strcpy(str,s); } else{ str = NULL; } return str;\t} String::~String() { if(str){ delete []str; } } int main(){ String s; s = \"Good Luck,\"; cout\u003c\u003cs.c_str()\u003c\u003cendl; //String s2 = \"hello!\" ; // error，因为这不能为初始化语句，而是赋值 s = \"Atom!\"; cout\u003c\u003cs.c_str()\u003c\u003cendl; return 0; } // output Good Luck, Atom! //实现深复制，规避浅复制 String::String(String \u0026s) { if(s){ str = new char[strlen(s) + 1]; strcpy(str,s); } else{ str = NULL; } } operator + overloaded as friend function. common function can not access private member\n普通函数不能访问私有成员\n运算符+重载为友元函数\nclass Complex{ double real, immage; public: Complex(double r, doulbe i): real(r), image(i){}; Complex operator+(double r); friend Complex operator+(double r, const Complex \u0026 c); }; Complex Complex::operator+(double r){ // 能解释 c + 5； return Complex(real + r, image); } int main(){ Complex c; c = c + 5; //有定义，c = c.operator + (5); c = 5 + c; // compiler error // 为了使 c = 5 + c;表达式成立，需要将+重载为普通函数，如下 Complex operator+(double r, const Complex \u0026c){ // 能解释 5 + c； return Complex(c.real + r, c.image); } return 0; } w3. Class, Object 类, 对象\nconstructor 构造函数 构造函数不能是虚函数。虽然在技术上可以声明虚构造函数，但这通常被认为是危险的，因为在构造函数中调用虚函数不会调用派生类中的重写版本。 构造函数中可以调用本类的静态成员函数。静态成员函数不依赖于类的实例，因此可以在构造函数中被调用。 使用 new 运算符动态创建对象时，并不一定要使用无参数的构造函数。如果类中定义了带参数的构造函数，也可以使用这些构造函数来初始化对象。 构造函数可以重载，有不同版本的构造函数，例如无参数（默认构造）、带参数、 通过赋值号 “=” 对一个对象进行赋值时，不会引发复制构造函数的调用。这会调用赋值运算符，而不是复制构造函数。 #include class MyClass { public: // 静态成员函数 static void staticFunc() { std::cout \u003c\u003c \"静态成员函数被调用\" \u003c\u003c std::endl; } // 构造函数 MyClass(int val) { std::cout \u003c\u003c \"带参数的构造函数被调用\" \u003c\u003c std::endl; // 调用静态成员函数 staticFunc(); } // 复制构造函数 MyClass(const MyClass\u0026 other) { std::cout \u003c\u003c \"复制构造函数被调用\" \u003c\u003c std::endl; } // 赋值运算符 MyClass\u0026 operator=(const MyClass\u0026 other) { std::cout \u003c\u003c \"赋值运算符被调用\" \u003c\u003c std::endl; return *this; } // 析构函数 ~MyClass() { std::cout \u003c\u003c \"析构函数被调用\" \u003c\u003c std::endl; } }; int main() { // 使用带参数的构造函数创建对象 MyClass obj1(10); // 使用复制构造函数创建对象 MyClass obj2 = obj1; // 赋值运算符的调用 MyClass obj3; obj3 = obj1; // 动态创建对象，使用带参数的构造函数 MyClass* obj4 = new MyClass(20); delete obj4; return 0; } copy constructor vs. assignment operator\n复制构造函数用于初始化新创建的对象；\n而赋值运算符用于已存在对象的赋值操作。\nInline Member Function, Overloaded Member Function, Default Argument\n内联成员函数，重载成员函数，参数缺省\ninline\ncopy constructor // 下面的程序不会调用A的复制构造函数 // 因为 a1 = a2 是赋值操作，而不是复制构造 A a1,a2; a1 = a2; // 传递一个A类型的对象时，调用了复制构造函数 void func( A a) { cout \u003c\u003c \"good\" \u003c\u003c endl; } // 返回局部对象tmp时，会调用复制构造函数 A func( ) { A tmp; return tmp; } // 通过已存在的对象a1来初始化a2，调用复制构造函数 A a1; A a2(a1); Conversion Constructor, Destructor 类型转换构造函数、析构函数\nit change right side int 6 to left side temporary Demo class, and assign the value 6 to d1.\nconstructed and destructed order.\nClass Demo{ int id; public: Demo(int i){ // Constructor id = i; cout\u003c\u003c\"id=\"\u003c\u003cid\u003c\u003c\"constructed\"\u003c\u003cendl; } ~Demo(){ cout\u003c\u003c\"id=\"\u003c\u003cid\u003c\u003c\"destructed\"\u003c\u003cendl; } }; Demo d1(1); // global variable firstly void Func(){ static Demo d2(2); // static varible destructed at the end of whole program. Demo d3(3); // object must be destructed within Scope. cout\u003c\u003c\"Func\"\u003c\u003cendl; } int main(){ Demo d4(4); d4 = 6; // Conversion Constructor temporary cout\u003c\u003c\"main\"\u003c\u003cendl; { Demo d5(5); } // object must be destructed within Scope. Fun(); cout\u003c\u003c\"main\"\u003c\u003cendl; return 0; } //output id=1 constructed; id=4 constructed; id=6 constructed; id=6 destructed; main id=5 constructed; id=5 destructed; id=2 constructed; id=3 constructed; Fun id=3 destructed; main ends id=6 destructed; id=2 destructed; id=1 destructed; static member variable, static member function 静态成员变量、静态成员函数\nstatic\n类的非静态成员函数完全可以访问静态成员变量。\n静态成员变量不属于类的任何单个对象，而是由类的所有对象共享。\n静态成员函数可以访问类的静态成员变量，但不能访问非静态成员变量，包括常量和非常量成员，因为静态成员函数不依赖于类的任何特定对象。\n不需要创建类的对象，就可以访问类的静态成员。\nfriend 友元 类C2是类C1的派生类，若函数f是C1的友元，它并不自动成为类C2的友元。友元关系是显式指定的，只适用于被明确声明的类。友元关系不会被继承。\n友元函数可以访问其友元类中的私有和保护成员，但这种访问权限不会传递给派生类。如果你希望函数f也成为类C2的友元，你需要在类C2中显式地声明f为友元：\nclass C1 { friend void f(); // f是C1的友元 }; class C2 : public C1 { friend void f(); // f也需要在C2中声明为友元 }; const object, const member function, const reference. 常量对象、常量成员函数、常引用\n参考案例：github/ PKUC3/ 3.10.1.2.cpp\n常量成员函数可以被任何对象调用，但它们不能修改对象的状态。常量对象只能调用常量成员函数。\nthis index, this 指针 this 指针是一个特殊的指针，它指向当前对象的实例。\nconst成员函数中、在虚函数中可以使用this指针。\n类的静态成员函数中，不能访问this指针。这是因为静态成员函数是属于类的，而不是某个特定对象的。因此，它们没有this指针，这个指针在非静态成员函数中用于指向调用函数的对象。 类的友元函数实际上不是类的成员函数，所以它们本身就没有this指针。但如果它们接受一个对象作为参数，它们可以访问该对象的非静态成员。 类的构造函数中可以访问this指针，因为构造函数是在对象创建时调用的，所以它们有一个指向新创建对象的this指针。 类的虚函数中也可以访问this指针，因为虚函数是与对象的动态类型相关联的，所以它们可以通过this指针访问调用它们的对象。 w2. from c to c++ 参考程序案例：github/ PKUC3/ 3.10.8.cpp\nBitwise operations\n位运算\n\u0026\n0 \u0026 0 = 0 0 \u0026 1 = 0 1 \u0026 0 = 0 1 \u0026 1 = 1 |\n0 | 0 = 0 0 | 1 = 1 1 | 0 = 1 1 | 1 = 1 ^\n0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 1 1 ^ 1 = 0 ~\n~1 = 0 ~0 = 1 ","wordCount":"1658","inLanguage":"zh","image":"https://atomx.cc/images/papermod-cover.png","datePublished":"2024-03-12T00:00:00Z","dateModified":"2024-03-12T00:00:00Z","author":{"@type":"Person","name":"Atom.X"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://atomx.cc/zh/posts/edu/math-cs/c++pku/pkuc3/"},"publisher":{"@type":"Organization","name":"Atom.X","logo":{"@type":"ImageObject","url":"https://atomx.cc/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://atomx.cc/zh/ accesskey=h title="Atom.X (Alt + H)">Atom.X</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://atomx.cc/ title=English aria-label=English>English</a></li><li><a href=https://atomx.cc/de/ title=Deutsch aria-label=Deutsch>Deutsch</a></li><li><a href=https://atomx.cc/nl/ title=Nederlands aria-label=Nederlands>Nederlands</a></li></ul></div></div><ul id=menu><li><a href=https://atomx.cc/zh/about/ title=关于><span>关于</span></a></li><li><a href=https://atomx.cc/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://atomx.cc/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://atomx.cc/zh/categories/ title=分类><span>分类</span></a></li><li><a href=https://atomx.cc/zh/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://coolshell.in/zh-cn/ title=酷壳众创><span>酷壳众创</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://atomx.cc/zh/>主页</a>&nbsp;»&nbsp;<a href=https://atomx.cc/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++程序设计</h1><div class=post-meta><span>2024-3-12</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;Atom.X</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#w11-c11-%e6%96%b0%e7%89%b9%e6%80%a7 aria-label="w11. C++11 新特性">w11. C++11 新特性</a><ul><li><a href=#%e5%bc%ba%e5%88%b6%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label=强制类型转换>强制类型转换</a></li><li><a href=#c%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e5%9f%ba%e7%a1%80trythrowcatch aria-label=C++异常处理基础：try、throw、catch>C++异常处理基础：try、throw、catch</a></li></ul></li><li><a href=#w9-stl-- aria-label="w9. STL -">w9. STL -</a><ul><li><a href=#container-adapter-%e5%ae%b9%e5%99%a8%e9%80%82%e9%85%8d%e5%99%a8 aria-label="container adapter 容器适配器">container adapter 容器适配器</a><ul><li><a href=#map-multimap aria-label="map/ multimap">map/ multimap</a></li><li><a href=#set-multiset aria-label="set/ multiset">set/ multiset</a></li><li><a href=#vector aria-label=vector>vector</a></li><li><a href=#list aria-label=list>list</a></li><li><a href=#deque aria-label=deque>deque</a></li></ul></li><li><a href=#the-algorithms-in-stl aria-label="The algorithms in STL">The algorithms in STL</a></li></ul></li><li><a href=#w8-stl---standard-template-library aria-label="w8. STL - standard template library">w8. STL - standard template library</a><ul><li><a href=#function-object-%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1 aria-label="function object 函数对象">function object 函数对象</a></li></ul></li><li><a href=#w7-file-operate-template aria-label="w7. file operate, template">w7. file operate, template</a><ul><li><a href=#template-class-%e6%a8%a1%e6%9d%bf%e7%b1%bb aria-label="template class 模板类">template class 模板类</a></li><li><a href=#class-template-%e7%b1%bb%e6%a8%a1%e6%9d%bf aria-label="class template 类模板">class template 类模板</a></li></ul></li><li><a href=#w6-polymorphism-virtual-function aria-label="w6. polymorphism, virtual function">w6. polymorphism, virtual function</a><ul><li><a href=#%e5%af%b9%e8%b1%a1%e8%b5%8b%e5%80%bc aria-label=对象赋值>对象赋值</a></li></ul></li><li><a href=#w4-operator-overloading aria-label="w4. operator overloading">w4. operator overloading</a><ul><ul><li><a href=#complex-number-%e5%a4%8d%e6%95%b0%e7%b1%bb aria-label="complex number 复数类">complex number 复数类</a></li></ul><li><a href=#operator- aria-label="operator[ ]">operator[ ]</a></li><li><a href=#operator aria-label="operator=">operator=</a></li><li><a href=#operator--overloaded-as-friend-function aria-label="operator + overloaded as friend function.">operator + overloaded as friend function.</a></li></ul></li><li><a href=#w3-class-object aria-label="w3. Class, Object">w3. Class, Object</a><ul><li><a href=#constructor-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label="constructor 构造函数">constructor 构造函数</a></li><li><a href=#copy-constructor aria-label="copy constructor">copy constructor</a></li><li><a href=#conversion-constructor-destructor aria-label="Conversion Constructor, Destructor">Conversion Constructor, Destructor</a></li><li><a href=#static-member-variable-static-member-function aria-label="static member variable, static member function">static member variable, static member function</a></li><li><a href=#friend-%e5%8f%8b%e5%85%83 aria-label="friend 友元">friend 友元</a></li><li><a href=#const-object-const-member-function-const-reference aria-label="const object, const member function, const reference.">const object, const member function, const reference.</a></li><li><a href=#this-index-this-%e6%8c%87%e9%92%88 aria-label="this index, this 指针">this index, this 指针</a></li></ul></li><li><a href=#w2-from-c-to-c aria-label="w2. from c to c++">w2. from c to c++</a></li></ul></div></details></div><div class=post-content><p>原课程链接：<a href=https://www.coursera.org/learn/cpp-chengxu-sheji/>C++程序设计</a></p><p><a href=https://cplusplus.com/>cplusplus.com</a></p><p>教材《新标准 c++程序设计》 郭炜, 清华大学</p><h1 id=w11-c11-新特性>w11. C++11 新特性<a hidden class=anchor aria-hidden=true href=#w11-c11-新特性>#</a></h1><p>auto 自动变量类型</p><p>decltype 关键字，求表达式类型</p><p>shared_ptr 智能指针</p><p>nullptr 空指针</p><p>基于范围的for循环</p><p>右值引用和move语义</p><p>unordered_map 无序容器(哈希表)</p><p>regex 正则表达式</p><p>Lambda 表达式</p><h2 id=强制类型转换>强制类型转换<a hidden class=anchor aria-hidden=true href=#强制类型转换>#</a></h2><p>static_cast、interpret_cast
const_cast和dynamic_cast</p><h2 id=c异常处理基础trythrowcatch>C++异常处理基础：try、throw、catch<a hidden class=anchor aria-hidden=true href=#c异常处理基础trythrowcatch>#</a></h2><p>意外异常(unexpected exception)
动态内存管理的异常处理 new</p><h1 id=w9-stl-->w9. STL -<a hidden class=anchor aria-hidden=true href=#w9-stl-->#</a></h1><p>质因数数目</p><h2 id=container-adapter-容器适配器><strong>container adapter 容器适配器</strong><a hidden class=anchor aria-hidden=true href=#container-adapter-容器适配器>#</a></h2><p>(让已有的顺序容器以栈/队列的方式工作)</p><p>stack</p><p>queue</p><p>priority_queue</p><p><strong>member function</strong></p><p>push</p><p>top</p><p>pop</p><p>参考案例：github/ PKUC3/ 3.10.1.4.cpp</p><h3 id=map-multimap>map/ multimap<a hidden class=anchor aria-hidden=true href=#map-multimap>#</a></h3><p><strong><code>map</code></strong> 容器中，关键字key是唯一的，值value可以重复。</p><p><strong><code>multimap</code></strong> 容器中，关键字和值都可以重复。</p><h3 id=set-multiset>set/ multiset<a hidden class=anchor aria-hidden=true href=#set-multiset>#</a></h3><p><strong><code>set</code></strong> 容器中，元素是唯一的，按其值自动排序，而非插入顺序。</p><p>添加新对象时会比较对象的大小，<strong><code>set</code></strong> 是一个基于红黑树实现的容器，它会自动将元素按照特定的顺序存储，通常是使用元素的 <strong><code>&lt;</code></strong> 操作符来进行比较和排序。</p><p><code>set</code> 容器的迭代器支持双向迭代，可以使用++，- - 移动迭代器，但不支持随机访问，所以不能进行 i+1 的操作；</p><p><strong><code>multiset</code></strong> 容器中，元素可以重复，并且按其值自动排序。</p><h3 id=vector>vector<a hidden class=anchor aria-hidden=true href=#vector>#</a></h3><p><strong><code>vector</code></strong> 容器支持随机访问，例如 <code>int i=0, num[i]</code>；</p><p>一个动态数组，可以在尾部快速添加或删除对象，但不会自动排序。</p><h3 id=list>list<a hidden class=anchor aria-hidden=true href=#list>#</a></h3><p><strong><code>list</code></strong> 容器是一个双向链表，可在任何位置快速添加或删除对象，不会自动排序；</p><p>不支持随机访问，只能通过顺序访问，因此不能使用下标操作符（<strong><code>[]</code></strong>），小于(<strong><code>&lt;</code></strong>)操作 或者在迭代器上进行加法操作（<strong><code>ii + 1</code></strong>）。</p><p>只能使用不等于(<strong><code>!=</code></strong>)操作符来比较迭代器和容器的**<code>end()</code>，<strong>以及迭代器的递增操作符（</strong><code>++</code>**），直到达到容器末尾：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>list</span> <span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span> <span class=n>list</span> <span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>const_iterator</span> <span class=n>ii</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 不等于(!=)操作，递增操作（++），正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=p>(</span><span class=n>ii</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>ii</span> <span class=o>!=</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=n>ii</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>ii</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 下标操作（[]），加法操作（ii + 1）， 小于操作(&lt;)，报错
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=p>(</span> <span class=n>ii</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>ii</span> <span class=o>!=</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span> <span class=p>();</span><span class=n>ii</span> <span class=o>=</span> <span class=n>ii</span> <span class=o>+</span><span class=mi>1</span> <span class=p>)</span> 
</span></span><span class=line><span class=cl>	  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span> <span class=n>ii</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>v</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>	  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span> <span class=n>ii</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>ii</span> <span class=o>&lt;</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span> <span class=p>();</span><span class=n>ii</span> <span class=o>++</span> <span class=p>)</span> 
</span></span><span class=line><span class=cl>	  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span> <span class=n>ii</span><span class=p>;</span>	
</span></span></code></pre></div><h3 id=deque>deque<a hidden class=anchor aria-hidden=true href=#deque>#</a></h3><p>一个双端队列，可以在头部和尾部快速添加或删除对象，但同样不会自动排序。</p><h2 id=the-algorithms-in-stl>The algorithms in STL<a hidden class=anchor aria-hidden=true href=#the-algorithms-in-stl>#</a></h2><p>• Non-modifying sequence algorithms
• Modifying sequence algorithms
• Removing algorithms
remove, unique,</p><p>• Mutating sequence algorithms
reverse, rotate</p><p>• Sorting algorithms</p><p>sort, nth_element</p><p>• Sorted range algorithms</p><p>binary_search, include, lower_bound, upper_bound, equal_range</p><p>• Numeric algorithms</p><h1 id=w8-stl---standard-template-library>w8. STL - standard template library<a hidden class=anchor aria-hidden=true href=#w8-stl---standard-template-library>#</a></h1><p>标准模板库STL，就是一些常用数据结构和算法的模板的集合。将常用的数据结构（比如链表，数组，二叉树）和算法（比如排序，查找）写成模板。</p><p>泛型程序设计(generic programming)</p><p>**容器：**可容纳各种数据类型的通用数据结构,是类模板；</p><ol><li>顺序容器
vector, deque, list</li><li>关联容器
set, multiset, map, multimap</li><li>容器适配器
stack, queue, priority_queue</li></ol><p>**迭代器：**可用于依次存取容器中元素，类似于指针；</p><p>容器上的迭代器类别</p><ul><li>vector 随机访问
deque 随机访问
list 双向
set/multiset 双向
map/multimap 双向
stack 不支持迭代器
queue 不支持迭代器
priority_queue 不支持迭代器</li></ul><p>**算法：**用来操作容器中的元素的函数模板；</p><ul><li>sort()来对一个vector中的数据进行排序</li><li>find()来搜索一个list中的对象</li></ul><h2 id=function-object-函数对象><strong>function object 函数对象</strong><a hidden class=anchor aria-hidden=true href=#function-object-函数对象>#</a></h2><p>如果一个类重载了**<code>()</code><strong>运算符，那么该类的对象可以像函数一样被调用，也叫</strong>仿函数**。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 创建一个Adder对象addFive，通过addFive(3)来调用，就像调用普通函数一样
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Adder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Adder</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=o>:</span> <span class=n>num</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=nf>operator</span><span class=p>()(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>num</span> <span class=o>+</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// 重载()运算符，Adder对象可接受整数参数并返回结果
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>num</span><span class=p>;</span> <span class=c1>// 内部状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Adder</span> <span class=n>addFive</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// 创建一个函数对象，内部状态为5
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>addFive</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span> <span class=c1>// 调用函数对象，输出8
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>C++ 中常用的数据结构</strong></p><ul><li><strong>集合（Set）</strong>：Set 是基于二叉搜索树（通常是红黑树）实现的，它的主要优点是查找、插入和删除操作的时间复杂度都是 O(logN)。但是，Set 不支持随机访问，即不能像数组或向量那样通过索引直接访问元素。</li><li><strong>向量（Vector）</strong>：Vector 是一种动态数组，它的主要优点是支持随机访问，访问元素的时间复杂度是 O(1)。但是，如果在 Vector 的中间位置插入或删除元素，可能需要移动大量的元素，所以这类操作的时间复杂度是 O(N)。</li><li><strong>列表（List）</strong>：List 是一种双向链表，它的主要优点是在任何位置插入或删除元素的时间复杂度都是 O(1)。但是，List 不支持随机访问，访问元素的时间复杂度是 O(N)。</li></ul><p><strong>O(logN) time.</strong>
• <code>set</code> provides fast lookup to check if an id exists in O(logN) time.</p><p>Big O notation is a way to express the upper bound of an algorithm’s time complexity, which is a measure of the amount of time an algorithm takes to run as a function of the size of its input.</p><p>Big O 表示法是一种表达算法时间复杂度上限的方法，它是算法运行时间的度量，作为其输入大小的函数。</p><p>随着元素数量 N 的增加，执行操作所需的时间并不是线性增加（就像在 O(N) 的情况下那样），而是以 N 的对数的比例增长。</p><p>假设p1, p2 是STL中的list 容器上的迭代器，<strong>p1 += 1;</strong> 不符合语法？</p><p>因为：<strong><code>list</code></strong> 容器的迭代器是双向迭代器，不支持随机访问和算术操作，因此不能直接使用 <strong><code>+=</code></strong> 来移动迭代器。</p><p>在STL中，<strong><code>list</code></strong> 容器的迭代器不支持 <strong><code>+=</code></strong> 操作符</p><p>移动迭代器 <strong><code>p1</code></strong> 到下一个位置，可以使用 <strong><code>++p1</code></strong> 或者 <strong><code>p1++</code></strong></p><h1 id=w7-file-operate-template>w7. file operate, template<a hidden class=anchor aria-hidden=true href=#w7-file-operate-template>#</a></h1><p>文件操作、模板</p><p>ifstream, ofstream, fstream</p><p>cin&#187; 输入</p><p>cout&#171; 输出</p><p>字符流</p><p>function template 函数模板</p><h2 id=template-class-模板类>template class 模板类<a hidden class=anchor aria-hidden=true href=#template-class-模板类>#</a></h2><p>common class 普通类</p><p>string class 是模板类</p><p>typedef basic_string<char> string;</p><p>用 <strong><code>template&lt;class T></code></strong> 定义一个类时，创建的是一个可以用于多种数据类型的模板，模板类不是一个具体的类实例，这个模板本身不是一个直接可以使用的类，而是一个用于生成特定类型实例的蓝图。</p><p>参考程序案例：github/ PKUC3/ 3.10.7.cpp</p><h2 id=class-template-类模板>class template 类模板<a hidden class=anchor aria-hidden=true href=#class-template-类模板>#</a></h2><p>题目：类C1和类C2都是类模板CT的模板类</p><ul><li>C1的成员函数中，<strong>不能</strong>访问C2的私有成员，除非C2将C1声明为友元。</li><li>C1的友元函数中，<strong>不能</strong>访问C2的私有成员，除非C2将该友元函数声明为友元。</li><li>C1的对象，<strong>不能</strong>直接赋值给C2类型的变量，除非它们是相同的类型或者有适当的类型转换操作定义。</li><li>C1的静态成员变量和C2的静态<strong>成员变量拥有不同的存储空间</strong>。这是因为即使C1和C2是由同一个类模板CT实例化出来的，如果它们的模板参数不同，它们就是不同的类型，每个类型都会有自己的静态成员变量实例。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 类模板定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CT</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 静态成员变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>int</span> <span class=n>staticValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>CT</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 初始化静态成员变量
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>staticValue</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 静态成员变量的定义和初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>CT</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>staticValue</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 实例化一个int类型的CT模板类
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>CT</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>intInstance</span><span class=p>;</span> <span class=c1>// 使用类名CT&lt;int&gt;创建对象名为intInstance的对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;CT&lt;int&gt;::staticValue: &#34;</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=n>CT</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>staticValue</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 实例化一个double类型的CT模板类
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 使用类名CT&lt;double&gt;创建对象名为doubleInstance的对象。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>CT</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>doubleInstance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;CT&lt;double&gt;::staticValue: &#34;</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=n>CT</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>staticValue</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 再次创建CT&lt;int&gt;的实例
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>CT</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>anotherIntInstance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;CT&lt;int&gt;::staticValue: &#34;</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=n>CT</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>staticValue</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 输出结果将显示CT&lt;int&gt;和CT&lt;double&gt;的staticValue是独立存储的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 两个实例intInstance和doubleInstance分别属于两个不同的模板类
</span></span></span><span class=line><span class=cl><span class=c1>// 它们是由同一个类模板（类名）CT通过提供不同的类型参数生成的。
</span></span></span></code></pre></div><p><strong>operator运算符:</strong></p><ul><li>算术运算符：<strong><code>+</code></strong>、<strong><code>**、**</code></strong>、<strong><code>/</code></strong> 等。</li><li>比较运算符：<strong><code>==</code></strong>、<strong><code>!=</code></strong>、<strong><code>&lt;</code></strong>、<strong><code>></code></strong> 等。</li><li>逻辑运算符：<strong><code>&&</code></strong>、<strong><code>||</code></strong>、<strong><code>!</code></strong> 等。</li><li>位运算符：<strong><code>&</code></strong>、<strong><code>|</code></strong>、<strong><code>^</code></strong> 等。</li></ul><p><strong>stream manipulator 流操纵符:</strong></p><p><code>cin , cout</code>(与<code>&lt;&lt;, >></code> 运算符一起使用)、<strong><code>setw</code></strong>、<strong><code>setfill</code></strong>、<strong><code>setprecision</code></strong>、<strong><code>endl</code></strong>、<strong><code>ws</code></strong>、<strong><code>ends</code></strong>、<strong><code>flush</code></strong></p><p>老版本的北大教材中使用“流操纵算子”的术语，在此统一翻译为“<strong>stream manipulator流操纵符</strong>”。</p><p>算子（数学概念）与计算机程序中的operator有相通之处，在最新版本的c++库说明文件中，“运算符”替代“算子”的术语。（此处术语有待勘误）</p><p>科学计数法（<strong>科学记号</strong>）是一种用于表示非常大或非常小数值的方法，形式：</p><p>[ \text{数} = a \times 10^n ]</p><p>(2.7 \times 10^3) = 2700</p><p>(-5.3 \times 10^4) = -53000</p><p>(7.823E5) = 782300</p><p>(1.2e^{-4}) = 0.00012</p><p><code>dec, hex, oct</code> format flag for output streams.</p><p><code>int</code> represents an integer value in <strong>decimal</strong> (base 10) format.</p><h1 id=w6-polymorphism-virtual-function><strong>w6. polymorphism, virtual function</strong><a hidden class=anchor aria-hidden=true href=#w6-polymorphism-virtual-function>#</a></h1><p>多态, 虚函数</p><p><strong>abstract class 抽象类</strong></p><p>包含至少一个纯虚函数（pure virtual function）的类</p><p>Abstract classes are used to represent general concepts (for example, <code>Shape</code>, <code>Animal</code>), which can serve as base classes for more specific concrete classes (for example, <code>Circle</code>, <code>Dog</code>).</p><ul><li>These general concepts often have common properties or behaviors that apply to their derived classes.</li><li>Abstract classes cannot be instantiated directly; they serve as blueprints for other classes.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span><span class=c1>// Abstract classes 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span> <span class=c1>// contain at least one pure virtual function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>virtual</span> <span class=kt>void</span> <span class=n>func</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;I am in base&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// **override identifier 标识符**
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span> <span class=c1>// override identifier specifies member 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span> <span class=c1>// function overrides virtual function in a base class
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>func</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;I am in derived class&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>pure virtual function 纯虚函数</p><p>virtual destructor 虚析构函数</p><p>若基类的成员函数被声明为虚函数（使用**<code>virtual</code><strong>关键字），那么在派生类中即使不再显式地使用</strong><code>virtual</code>**关键字，该成员函数仍然是虚函数。派生类会继承基类的虚函数属性，并且可以通过多态性来覆盖这些虚函数。</p><p>override in derived class 從派生類重寫</p><p>If a derived class overrides a base class method, that method becomes virtual implicitly in the base class. 如果派生类重写基类方法，则该方法在基类中隐式变为虚拟方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 参考程序案例：github/ PKUC3/ 3.10.1.1.cpp 
</span></span></span><span class=line><span class=cl><span class=c1>// 程序示例，展示虚函数表、虚函数、纯虚函数和抽象类的用法 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 抽象类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 纯虚函数，用于计算面积
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>double</span> <span class=n>area</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 虚析构函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Shape</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 派生类：圆形
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Circle</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>radius</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Circle</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>)</span> <span class=o>:</span> <span class=n>radius</span><span class=p>(</span><span class=n>r</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 重写纯虚函数，计算圆形的面积
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=nf>area</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mf>3.14159</span> <span class=o>*</span> <span class=n>radius</span> <span class=o>*</span> <span class=n>radius</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 派生类：矩形
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Rectangle</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Rectangle</span><span class=p>(</span><span class=kt>double</span> <span class=n>w</span><span class=p>,</span> <span class=kt>double</span> <span class=n>h</span><span class=p>)</span> <span class=o>:</span> <span class=n>width</span><span class=p>(</span><span class=n>w</span><span class=p>),</span> <span class=n>height</span><span class=p>(</span><span class=n>h</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 重写纯虚函数，计算矩形的面积
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=nf>area</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>width</span> <span class=o>*</span> <span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 不能直接创建抽象类的实例
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Shape shape; // 错误：不能实例化抽象类
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建派生类的实例
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Circle</span> <span class=n>circle</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Rectangle</span> <span class=n>rectangle</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用指向基类的指针数组来调用派生类的函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Shape</span><span class=o>*</span> <span class=n>shapes</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=o>&amp;</span><span class=n>circle</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rectangle</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 通过基类指针调用重写的函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Shape &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; area: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>shapes</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>area</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=对象赋值><strong>对象赋值</strong><a hidden class=anchor aria-hidden=true href=#对象赋值>#</a></h2><p>如果类C2是类C1的派生类，那么可以将C2的对象赋值给C1类型的变量。多态特性，允许派生类对象被视为基类对象，通过指针或引用来实现的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>C1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// 基类成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C2</span> <span class=o>:</span> <span class=k>public</span> <span class=n>C1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// 派生类成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=n>C2</span> <span class=n>objC2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>C1</span><span class=o>*</span> <span class=n>ptrC1</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>objC2</span><span class=p>;</span> <span class=c1>// C2的对象可以赋值给C1类型的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>C1</span><span class=o>&amp;</span> <span class=n>refC1</span> <span class=o>=</span> <span class=n>objC2</span><span class=p>;</span>  <span class=c1>// C2的对象也可以赋值给C1类型的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=w4-operator-overloading>w4. operator overloading<a hidden class=anchor aria-hidden=true href=#w4-operator-overloading>#</a></h1><p>运算符重载</p><p>流插入运算符和流提取运算符的重载</p><p>cout&#171;左移，cin&#187;右移，位运算符</p><h3 id=complex-number-复数类>complex number 复数类<a hidden class=anchor aria-hidden=true href=#complex-number-复数类>#</a></h3><p>用于表示和操作复数的编程类</p><p><code>a + bi</code></p><p>（a）是实数部分，( b ) 是虚数部分，而 ( i ) 是虚数单位，满足 ( i^2 = -1 )。</p><p>普通函数，传入2个参数</p><p>成员函数，传入1个</p><h2 id=operator->operator[ ]<a hidden class=anchor aria-hidden=true href=#operator->#</a></h2><p><strong>index operator,</strong> <strong>subscript operator overloading</strong></p><p>下标运算符重载</p><h2 id=operator>operator=<a hidden class=anchor aria-hidden=true href=#operator>#</a></h2><p>assignment operator overloading</p><p>赋值运算符重载</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>String</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>String</span><span class=p>()</span><span class=o>:</span><span class=n>str</span><span class=p>(</span><span class=nb>NULL</span><span class=p>){}</span> <span class=c1>// 构造函数，初始化为NULL
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>c_str</span><span class=p>(){</span> <span class=k>return</span> <span class=n>str</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=kt>char</span> <span class=o>*</span><span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>String</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//重载‘=’→ object = &#34;hello&#34; 能够成立 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=n>String</span><span class=o>::</span><span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>str</span> <span class=o>==</span> <span class=n>s</span><span class=p>.</span><span class=n>str</span><span class=p>){</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>str</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=k>delete</span><span class=p>[]</span> <span class=n>str</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>){</span> <span class=c1>// s！= NULL 时才执行copy
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>str</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>s</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>str</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>str</span><span class=p>;</span>	
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>String</span><span class=o>::~</span><span class=n>String</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=n>str</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=k>delete</span> <span class=p>[]</span><span class=n>str</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>		<span class=n>String</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>s</span> <span class=o>=</span> <span class=s>&#34;Good Luck,&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>s</span><span class=p>.</span><span class=n>c_str</span><span class=p>()</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=c1>//String s2 = &#34;hello!&#34; ; // error，因为这不能为初始化语句，而是赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>s</span> <span class=o>=</span> <span class=s>&#34;Atom!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>s</span><span class=p>.</span><span class=n>c_str</span><span class=p>()</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1>// output
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Good</span> <span class=n>Luck</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>	<span class=n>Atom</span><span class=o>!</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//实现深复制，规避浅复制
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>String</span><span class=o>::</span><span class=n>String</span><span class=p>(</span><span class=n>String</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>){</span> 
</span></span><span class=line><span class=cl>		<span class=n>str</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>s</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>str</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=operator--overloaded-as-friend-function>operator + overloaded as friend function.<a hidden class=anchor aria-hidden=true href=#operator--overloaded-as-friend-function>#</a></h2><p>common function can not access private member</p><p>普通函数不能访问私有成员</p><p>运算符+重载为友元函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>real</span><span class=p>,</span> <span class=n>immage</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>	<span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span> <span class=n>doulbe</span> <span class=n>i</span><span class=p>)</span><span class=o>:</span> <span class=n>real</span><span class=p>(</span><span class=n>r</span><span class=p>),</span> <span class=n>image</span><span class=p>(</span><span class=n>i</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>	<span class=n>Complex</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>Complex</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span> <span class=k>const</span> <span class=n>Complex</span> <span class=o>&amp;</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Complex</span> <span class=n>Complex</span><span class=o>::</span><span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>){</span> <span class=c1>// 能解释 c + 5；
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nf>Complex</span><span class=p>(</span><span class=n>real</span> <span class=o>+</span> <span class=n>r</span><span class=p>,</span> <span class=n>image</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Complex</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>c</span> <span class=o>=</span> <span class=n>c</span> <span class=o>+</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>//有定义，c = c.operator + (5);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>c</span> <span class=o>=</span> <span class=mi>5</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span> <span class=c1>// compiler error 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 为了使 c = 5 + c;表达式成立，需要将+重载为普通函数，如下
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Complex</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span> <span class=k>const</span> <span class=n>Complex</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 能解释 5 + c；
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=n>Complex</span><span class=p>(</span><span class=n>c</span><span class=p>.</span><span class=n>real</span> <span class=o>+</span> <span class=n>r</span><span class=p>,</span> <span class=n>c</span><span class=p>.</span><span class=n>image</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=w3-class-object>w3. Class, Object<a hidden class=anchor aria-hidden=true href=#w3-class-object>#</a></h1><p>类, 对象</p><h2 id=constructor-构造函数>constructor 构造函数<a hidden class=anchor aria-hidden=true href=#constructor-构造函数>#</a></h2><ul><li><a href=https://www.geeksforgeeks.org/calling-virtual-methods-in-constructordestructor-in-cpp/>构造函数<strong>不能</strong>是虚函数。虽然在技术上可以声明虚构造函数，但这通常被认为是危险的，因为在构造函数中调用虚函数不会调用派生类中的重写版本</a>。</li><li><a href=https://stackoverflow.com/questions/5855046/can-constructor-be-called-from-static-functions>构造函数中<strong>可以</strong>调用本类的静态成员函数。静态成员函数不依赖于类的实例，因此可以在构造函数中被调用</a>。</li><li><a href=https://stackoverflow.com/questions/29329212/new-operator-default-constructor-in-c>使用 <strong><code>new</code></strong> 运算符动态创建对象时，并不一定要使用无参数的构造函数。如果类中定义了带参数的构造函数，也可以使用这些构造函数来初始化对象</a>。</li><li>构造函数可以重载，有不同版本的构造函数，例如无参数（默认构造）、带参数、</li><li><a href=https://www.geeksforgeeks.org/copy-constructor-vs-assignment-operator-in-c/>通过赋值号 “=” 对一个对象进行赋值时，<strong>不会</strong>引发复制构造函数的调用。这会调用赋值运算符，而不是复制构造函数</a>。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=c1>// 静态成员函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=n>staticFunc</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;静态成员函数被调用&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;带参数的构造函数被调用&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 调用静态成员函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>staticFunc</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 复制构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=p>(</span><span class=k>const</span> <span class=n>MyClass</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;复制构造函数被调用&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 赋值运算符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>MyClass</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;赋值运算符被调用&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 析构函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>~</span><span class=n>MyClass</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;析构函数被调用&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// 使用带参数的构造函数创建对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span> <span class=n>obj1</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 使用复制构造函数创建对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span> <span class=n>obj2</span> <span class=o>=</span> <span class=n>obj1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 赋值运算符的调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span> <span class=n>obj3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>obj3</span> <span class=o>=</span> <span class=n>obj1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 动态创建对象，使用带参数的构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>*</span> <span class=n>obj4</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MyClass</span><span class=p>(</span><span class=mi>20</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>obj4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>copy constructor vs. assignment operator</strong></p><p><strong>复制构造函数</strong>用于初始化新创建的对象；</p><p>而<strong>赋值运算符</strong>用于已存在对象的赋值操作。</p><p><strong>Inline Member Function, Overloaded Member Function, Default Argument</strong></p><p>内联成员函数，重载成员函数，参数缺省</p><p>inline</p><h2 id=copy-constructor>copy constructor<a hidden class=anchor aria-hidden=true href=#copy-constructor>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 下面的程序不会调用A的复制构造函数
</span></span></span><span class=line><span class=cl><span class=c1>// 因为 a1 = a2 是赋值操作，而不是复制构造
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=n>a1</span><span class=p>,</span><span class=n>a2</span><span class=p>;</span> <span class=n>a1</span> <span class=o>=</span> <span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 传递一个A类型的对象时，调用了复制构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span> <span class=n>A</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;good&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=c1>// 返回局部对象tmp时，会调用复制构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=nf>func</span><span class=p>(</span> <span class=p>)</span> <span class=p>{</span> <span class=n>A</span> <span class=n>tmp</span><span class=p>;</span> <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 通过已存在的对象a1来初始化a2，调用复制构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=n>a1</span><span class=p>;</span> <span class=n>A</span> <span class=nf>a2</span><span class=p>(</span><span class=n>a1</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=conversion-constructor-destructor>Conversion Constructor, Destructor<a hidden class=anchor aria-hidden=true href=#conversion-constructor-destructor>#</a></h2><p>类型转换构造函数、析构函数</p><p>it change right side int 6 to left side temporary Demo class, and assign the value 6 to d1.</p><p>constructed and destructed order.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Class</span> <span class=n>Demo</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Demo</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>){</span> <span class=c1>// Constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>id</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;id=&#34;</span><span class=o>&lt;&lt;</span><span class=n>id</span><span class=o>&lt;&lt;</span><span class=s>&#34;constructed&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>Demo</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;id=&#34;</span><span class=o>&lt;&lt;</span><span class=n>id</span><span class=o>&lt;&lt;</span><span class=s>&#34;destructed&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Demo</span> <span class=nf>d1</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=c1>// global variable firstly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Func</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=n>Demo</span> <span class=n>d2</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=c1>// static varible destructed at the end of whole program.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Demo</span> <span class=n>d3</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span> <span class=c1>// object must be destructed within Scope.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;Func&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Demo</span> <span class=n>d4</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>d4</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span> <span class=c1>// Conversion Constructor temporary
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;main&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span> <span class=n>Demo</span> <span class=n>d5</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span> <span class=p>}</span> <span class=c1>// object must be destructed within Scope.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;main&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//output
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>id</span><span class=o>=</span><span class=mi>1</span> <span class=n>constructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>4</span> <span class=n>constructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>6</span> <span class=n>constructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>6</span> <span class=n>destructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>main</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>5</span> <span class=n>constructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>5</span> <span class=n>destructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>2</span> <span class=n>constructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>3</span> <span class=n>constructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Fun</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>3</span> <span class=n>destructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>main</span> <span class=n>ends</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>6</span> <span class=n>destructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>2</span> <span class=n>destructed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>1</span> <span class=n>destructed</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=static-member-variable-static-member-function>static member variable, static member function<a hidden class=anchor aria-hidden=true href=#static-member-variable-static-member-function>#</a></h2><p>静态成员变量、静态成员函数</p><p>static</p><p>类的非静态成员函数完全可以访问静态成员变量。</p><p>静态成员变量不属于类的任何单个对象，而是由类的所有对象共享。</p><p>静态成员函数可以访问类的静态成员变量，但不能访问非静态成员变量，包括常量和非常量成员，因为静态成员函数不依赖于类的任何特定对象。</p><p>不需要创建类的对象，就可以访问类的静态成员。</p><h2 id=friend-友元>friend 友元<a hidden class=anchor aria-hidden=true href=#friend-友元>#</a></h2><p>类C2是类C1的派生类，若函数f是C1的友元，它并不自动成为类C2的友元。友元关系是显式指定的，只适用于被明确声明的类。友元关系不会被继承。</p><p>友元函数可以访问其友元类中的私有和保护成员，但这种访问权限不会传递给派生类。如果你希望函数f也成为类C2的友元，你需要在类C2中显式地声明f为友元：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>C1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=kt>void</span> <span class=nf>f</span><span class=p>();</span> <span class=c1>// f是C1的友元
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C2</span> <span class=o>:</span> <span class=k>public</span> <span class=n>C1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=kt>void</span> <span class=nf>f</span><span class=p>();</span> <span class=c1>// f也需要在C2中声明为友元
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h2 id=const-object-const-member-function-const-reference>const object, const member function, const reference.<a hidden class=anchor aria-hidden=true href=#const-object-const-member-function-const-reference>#</a></h2><p>常量对象、常量成员函数、常引用</p><p>参考案例：<code>github/ PKUC3/ 3.10.1.2.cpp</code></p><p>常量成员函数可以被任何对象调用，但它们不能修改对象的状态。常量对象只能调用常量成员函数。</p><h2 id=this-index-this-指针>this index, this 指针<a hidden class=anchor aria-hidden=true href=#this-index-this-指针>#</a></h2><p><strong><code>this</code></strong> 指针是一个特殊的指针，它指向当前对象的实例。</p><p>const成员函数中、在虚函数中可以使用this指针。</p><ul><li><strong>类的静态成员函数中，不能访问this指针</strong>。这是因为静态成员函数是属于类的，而不是某个特定对象的。因此，它们没有this指针，这个指针在非静态成员函数中用于指向调用函数的对象。</li><li><strong>类的友元函数实际上不是类的成员函数，所以它们本身就没有this指针</strong>。但如果它们接受一个对象作为参数，它们可以访问该对象的非静态成员。</li><li><strong>类的构造函数中可以访问this指针</strong>，因为构造函数是在对象创建时调用的，所以它们有一个指向新创建对象的this指针。</li><li><strong>类的虚函数中也可以访问this指针</strong>，因为虚函数是与对象的动态类型相关联的，所以它们可以通过this指针访问调用它们的对象。</li></ul><h1 id=w2-from-c-to-c><strong>w2. from c to c++</strong><a hidden class=anchor aria-hidden=true href=#w2-from-c-to-c>#</a></h1><p>参考程序案例：github/ PKUC3/ 3.10.8.cpp</p><p><strong>Bitwise operations</strong></p><p>位运算</p><p><strong>&</strong></p><ul><li>0 & 0 = 0</li><li>0 & 1 = 0</li><li>1 & 0 = 0</li><li>1 & 1 = 1</li></ul><p><strong>|</strong></p><ul><li>0 | 0 = 0</li><li>0 | 1 = 1</li><li>1 | 0 = 1</li><li>1 | 1 = 1</li></ul><p><strong>^</strong></p><ul><li>0 ^ 0 = 0</li><li>0 ^ 1 = 1</li><li>1 ^ 0 = 1</li><li>1 ^ 1 = 0</li></ul><p><strong>~</strong></p><ul><li>~1 = 0</li><li>~0 = 1</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://atomx.cc/zh/tags/%E4%BA%92%E8%81%94%E7%BD%91/>互联网</a></li><li><a href=https://atomx.cc/zh/tags/%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA/>数学&计算机</a></li><li><a href=https://atomx.cc/zh/tags/ai/>AI</a></li></ul><nav class=paginav><a class=prev href=https://atomx.cc/zh/posts/god/simple-bible-study-method/><span class=title>« 上一页</span><br><span>简易查经法</span>
</a><a class=next href=https://atomx.cc/zh/posts/life/culture-impact-and-identity1/><span class=title>下一页 »</span><br><span>文化冲击和身份认同1</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share C++程序设计 on x" href="https://x.com/intent/tweet/?text=C%2b%2b%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1&amp;url=https%3a%2f%2fatomx.cc%2fzh%2fposts%2fedu%2fmath-cs%2fc%2b%2bpku%2fpkuc3%2f&amp;hashtags=%e4%ba%92%e8%81%94%e7%bd%91%2c%e6%95%b0%e5%ad%a6%26%e8%ae%a1%e7%ae%97%e6%9c%ba%2cAI"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++程序设计 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fatomx.cc%2fzh%2fposts%2fedu%2fmath-cs%2fc%2b%2bpku%2fpkuc3%2f&amp;title=C%2b%2b%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1&amp;summary=C%2b%2b%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1&amp;source=https%3a%2f%2fatomx.cc%2fzh%2fposts%2fedu%2fmath-cs%2fc%2b%2bpku%2fpkuc3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++程序设计 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fatomx.cc%2fzh%2fposts%2fedu%2fmath-cs%2fc%2b%2bpku%2fpkuc3%2f&title=C%2b%2b%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++程序设计 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fatomx.cc%2fzh%2fposts%2fedu%2fmath-cs%2fc%2b%2bpku%2fpkuc3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++程序设计 on whatsapp" href="https://api.whatsapp.com/send?text=C%2b%2b%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%20-%20https%3a%2f%2fatomx.cc%2fzh%2fposts%2fedu%2fmath-cs%2fc%2b%2bpku%2fpkuc3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++程序设计 on telegram" href="https://telegram.me/share/url?text=C%2b%2b%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1&amp;url=https%3a%2f%2fatomx.cc%2fzh%2fposts%2fedu%2fmath-cs%2fc%2b%2bpku%2fpkuc3%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++程序设计 on ycombinator" href="https://news.ycombinator.com/submitlink?t=C%2b%2b%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1&u=https%3a%2f%2fatomx.cc%2fzh%2fposts%2fedu%2fmath-cs%2fc%2b%2bpku%2fpkuc3%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>© <a href=https://atomx.cc>Atom.X</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>